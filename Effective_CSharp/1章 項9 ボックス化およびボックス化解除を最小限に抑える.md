# 1章 項9 ボックス化およびボックス化解除を最小限に抑える

# 値型、参照型の使用用途
||値型|参照型|
|---|---|---|
|**用途**|変数が値を直接保持する|変数が情報の参照先を保持する(実態は他の場所にある)|

# もっと値型と参照型を掘り下げてみる

参考 

https://ufcpp.net/study/csharp/oo_reference.html

## C#の型の分類

||組み込み型|ユーザー定義型|他の型から合成|
|---|---|---|---|
|**値型**|単純型|構造体<br>列挙型|Null許容型|
|**参照型**|文字列型<br>オブジェクト型|クラス<br>インターフェイス<br>デリゲート<br>|配列|

## 構造体とクラスの違い
- 構造体 : 値型
- クラス : 参照型
### 構文的な違い
- 構造体
    - クラスと定義できることは同じ
    - 最初の宣言は「struct」を使う
    ```c#
    public struct Point
    {
        //  プロパティ
        public int data{get;set;}

        //  コンストラクタ
        public Point(){}

        //  メソッド
        public void TestMethod(){}
    }
    ```
- クラス
    - 構造体と定義できることは同じ
    - 最初の宣言は「class」を使う
    ```c#
    public class Point
    {
        //  プロパティ
        public int data{get;set;}

        //  コンストラクタ
        public Point(){}

        //  メソッド
        public void TestMethod(){}
    }
    ```

### 内部処理の違い

- 構造体
    - 代入時

    ```c#
    //  値型は代入時に値のコピーを受け取る
    ```

- クラス
    - 代入時
    ```c#
    //  参照型は値の実体(ヒープにある)への参照を受け取る
    ```

# ボックス化は値型を参照型のように使いたい場合に使われる

- 使われると書いたのは、プログラマー自身は特に意識せずにボックス化されているから

## 例 : 補完文字列を使用したログの吐き出し
```c#
int data = 1;

Console.WriteLine($"{data}だよ");

//  => 1だよ
```
- 補完文字列は、System.Objectへの参照の配列を使用して作成される
    - = 値型をボックス化している
- 普通に使用するには便利だが、内部の処理を覗くとオーバーヘッドが多少なりともある

## 例の内部処理を実際に書くと

```c#
int data = 1;

//  === ここから内部処理に置き換える ===

//  ボックス化
object o = data;

//  oに対してToString()を呼び出して内部の値にアクセスする
Console.WriteLine(o.ToString() + "だよ");

//  => 1だよ
```

## 内部処理を改善するためには
- WriteLineへ渡す前にあらかじめ文字列インスタンスへ変換しておく

    ```c#
    int data = 1;

    Console.WriteLine($@"{data.ToString()}だよ");

    //  => 1だよ
    ```

# なぜボックス化とボックス化解除は避ける必要があるのか

- ボックスに格納された値型を参照する場合、毎回、格納された値のコピーが作成されて返される

# 回避するには?

- ジェネリック型を使用する